int	do_pipe_execute(t_element *ptr, int (*pipes)[2], int _pipe_count)
{
	int		status;
	int		i;
	int		pipe_ct;
	int		instream;
	int		outstream;
	int		a;
	
	printf("%d\n", _pipe_count);
	i = 0;
	status = 0;
	while (ptr)
	{
		ptr->proc_id = fork();
		if (ptr->proc_id == 0)
		{
			dup2(ptr->command->in, STDIN_FILENO);
			dup2(ptr->command->out, STDOUT_FILENO);
			if (i == 0)
			{
				dup2(pipes[i][1], STDOUT_FILENO);
			}
			else if (i > 0 && i < (_pipe_count - 1))
			{
				outstream = pipe_or_redir_out(ptr->command, pipes, i);
				instream = pipe_or_redir_input(ptr->command, pipes, i);
				dup2(instream, STDIN_FILENO);
				dup2(outstream, STDOUT_FILENO);
			}
			else
			{
				dup2(pipes[i - 1][0], STDIN_FILENO);
				dup2(ptr->command->out, STDOUT_FILENO);
			}
			close_all_pipes(pipes, pipe_ct - 1);
			if(execve(get_abs_path(get_paths(), ptr->command->cmd), ptr->command->args, g_lobal->real_env) == -1)
			{
				fprintf(stderr, "Command Not found\n");
				exit (set_status(127));
			}
		}
		close_all_pipes(pipes, pipe_ct - 1);
		ptr = ptr->next;
		i++;
	}
	close_all_pipes(pipes, pipe_ct - 1);
	wait(&status);
	return (set_status(status));
}